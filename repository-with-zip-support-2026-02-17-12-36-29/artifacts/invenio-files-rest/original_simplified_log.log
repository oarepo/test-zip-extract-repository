 postgresql Pulling 
 opensearch Pulling 
 rabbitmq Pulling 
 redis Pulling 
 4f4fb700ef54 Already exists 
 4f4fb700ef54 Already exists 
 redis Pulled 
 rabbitmq Pulled 
 postgresql Pulled 
 opensearch Pulled 
 Network docker_services_cli_default  Creating
 Network docker_services_cli_default  Created
 Container docker_services_cli-rabbitmq-1  Creating
 Container docker_services_cli-redis-1  Creating
 Container docker_services_cli-opensearch-1  Creating
 Container docker_services_cli-postgresql-1  Creating
 Container docker_services_cli-redis-1  Created
 Container docker_services_cli-opensearch-1  Created
 Container docker_services_cli-postgresql-1  Created
 Container docker_services_cli-rabbitmq-1  Created
 Container docker_services_cli-rabbitmq-1  Starting
 Container docker_services_cli-postgresql-1  Starting
 Container docker_services_cli-opensearch-1  Starting
 Container docker_services_cli-redis-1  Starting
 Container docker_services_cli-postgresql-1  Started
 Container docker_services_cli-opensearch-1  Started
 Container docker_services_cli-redis-1  Started
 Container docker_services_cli-rabbitmq-1  Started
============================= test session starts ==============================
platform linux -- Python 3.14.2, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-files-rest/original
configfile: setup.cfg
testpaths: tests, invenio_files_rest
plugins: invenio-4.0.0, isort-4.0.0, flask-1.3.0, github-actions-annotate-failures-0.3.0, pydocstyle-2.4.0, cov-7.0.0, black-0.6.0, pycodestyle-2.5.0
collected 221 items
tests/test_admin.py 
                                                   [  0%]
tests/test_cli.py 
                                                      [  1%]
tests/test_helpers.py .                                                  [  1%]
tests/test_invenio_files_rest.py 
                                     [  3%]
tests/test_limiters.py .                                                 [  3%]
tests/test_models.py 
         [ 23%]
tests/test_models_multipart.py 
                                      [ 24%]
tests/test_request.py .                                                  [ 25%]
tests/test_serializer.py .                                               [ 25%]
tests/test_signals.py .                                                  [ 26%]
tests/test_storage.py ...................                                [ 34%]
tests/test_tasks.py .......                                              [ 38%]
tests/test_views_bucket.py .....................                         [ 47%]
tests/test_views_location.py ......                                      [ 50%]
tests/test_views_multipart.py ..EEEE.::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=108::test_post_invalid_partsizes%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=143::test_post_size_limits%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=171::test_post_locked_bucket%0A%0Aassert 404 == 403%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=205::test_post_invalidkey%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F......::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=283::test_put_wrong_sizes%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=300::test_put_ngfileupload%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=315::test_put_invalid_part_number%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=331::test_put_completed_multipart%0A%0Aassert 404 == 403%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=346::test_put_badstream%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F.....::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=395::test_get_empty%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=409::test_get_serialization%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F
::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=516::test_post_complete_fail%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=549::test_post_complete_timeout%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F...... [ 69%]
::error file=workdir/tests/invenio-files-rest/original/tests/test_views_multipart.py,line=672::test_already_exhausted_input_stream%0A%0Aassert 404 == 500%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F                                                                  [ 72%]
tests/test_views_objectversion.py EEE
::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=195::test_get_unreadable_file%0A%0Aassert 404 == 503%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F...........EEEEEEEE.::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=376::test_put_file_size_errors[50-100-400-Bucket quota]%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=376::test_put_file_size_errors[100-50-400-Maximum file size]%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=376::test_put_file_size_errors[100-100-200-None]%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=376::test_put_file_size_errors[None-None-200-None]%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F [ 89%]
::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=397::test_put_invalid_key%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=410::test_put_zero_size%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=423::test_put_deleted_locked%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=447::test_put_error%0A%0Aassert 404 == 400%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=474::test_put_multipartform%0A%0Aassert 404 == 200%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F..........::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=587::test_delete_versions_head_reset%0A%0Aassert 404 == 204%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=606::test_delete_locked_deleted%0A%0Aassert 404 == 403%0A +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
F::error file=workdir/tests/invenio-files-rest/original/tests/test_views_objectversion.py,line=646::test_delete_unwritable%0A%0AAssertionError: assert False%0A +  where False = <MagicMock name='remove_file_data.delay' id='139878602961456'>.called%0A +    where <MagicMock name='remove_file_data.delay' id='139878602961456'> = <MagicMock name='remove_file_data' id='139878563795296'>.delay
F....                                                   [ 99%]
invenio_files_rest/__init__.py 
                                         [100%]
==================================== ERRORS ====================================
________________ ERROR at setup of test_post_init[objects-404] _________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3802c4fb60>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ ERROR at setup of test_post_init[bucket-200] _________________
self = <sqlalchemy.engine.base.Connection object at 0x7f380279b2f0>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
________________ ERROR at setup of test_post_init[location-200] ________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3802c4c140>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
_________________ ERROR at setup of test_post_init_querystring _________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3802e40140>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
________________ ERROR at setup of test_get_not_found[None-404] ________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3801003c50>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
________________ ERROR at setup of test_get_not_found[auth-404] ________________
self = <sqlalchemy.engine.base.Connection object at 0x7f380124c140>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
______________ ERROR at setup of test_get_not_found[objects-404] _______________
self = <sqlalchemy.engine.base.Connection object at 0x7f3801472120>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
____________________ ERROR at setup of test_post[auth-404] _____________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3800b0fe30>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
___________________ ERROR at setup of test_post[bucket-403] ____________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3800b47b60>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
__________________ ERROR at setup of test_post[location-403] ___________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3800ba3890>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
_____________________ ERROR at setup of test_put[None-404] _____________________
self = <sqlalchemy.engine.base.Connection object at 0x7f3800baf5c0>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
_____________________ ERROR at setup of test_put[auth-404] _____________________
self = <sqlalchemy.engine.base.Connection object at 0x7f37ffbeb2f0>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
___________________ ERROR at setup of test_put[objects-404] ____________________
self = <sqlalchemy.engine.base.Connection object at 0x7f37ffb13020>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
____________________ ERROR at setup of test_put[bucket-200] ____________________
self = <sqlalchemy.engine.base.Connection object at 0x7f37ffb76d50>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
___________________ ERROR at setup of test_put[location-200] ___________________
self = <sqlalchemy.engine.base.Connection object at 0x7f37ffbe8b90>
engine = Engine(postgresql+psycopg2://invenio:***@localhost:5432/postgres)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True
    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
The above exception was the direct cause of the following exception:
app = <Flask 'testapp'>
    @pytest.yield_fixture()
    def db(app):
        """Get setup database."""
        if not database_exists(str(db_.engine.url.render_as_string(hide_password=False))):
>           create_database(str(db_.engine.url.render_as_string(hide_password=False)))
tests/conftest.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/sqlalchemy_utils/functions/database.py:568: in create_database
    with engine.begin() as conn:
         ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.14.2/x64/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3249: in begin
    with self.connect() as conn:
         ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3285: in connect
    return self._connection_cls(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:145: in __init__
    Connection._handle_dbapi_exception_noconnection(
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:2448: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:143: in __init__
    self._dbapi_connection = engine.raw_connection()
                             ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/base.py:3309: in raw_connection
    return self.pool.connect()
           ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:447: in connect
    return _ConnectionFairy._checkout(self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:1264: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:711: in checkout
    rec = pool._do_get()
          ^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:177: in _do_get
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/impl.py:175: in _do_get
    return self._create_connection()
           ^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:388: in _create_connection
    return _ConnectionRecord(self)
           ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:673: in __init__
    self.__connect()
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:899: in __connect
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.14/site-packages/sqlalchemy/pool/base.py:895: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/create.py:661: in connect
    return dialect.connect(*cargs, **cparams)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/sqlalchemy/engine/default.py:630: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)  # type: ignore[no-any-return]  # NOQA: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
dsn = 'host=localhost dbname=postgres user=invenio password=invenio port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'postgres', 'host': 'localhost', 'password': 'invenio', 'port': 5432, ...}
kwasync = {}
    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection
        The connection parameters can be specified as a string:
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
        or using a set of keyword arguments:
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
        Or as a mix of both. The basic connection parameters are:
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor()
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword)
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
E       	Is the server running on that host and accepting TCP/IP connections?
E       connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)
venv/lib/python3.14/site-packages/psycopg2/__init__.py:122: OperationalError
=================================== FAILURES ===================================
_________________________ test_post_invalid_partsizes __________________________
client = <FlaskClient <Flask 'testapp'>>
headers = {'Accept': '*/*', 'Content-Type': 'application/json'}
bucket = 8364e4be-30c9-4837-8361-20273c4b117b
get_json = <function get_json.<locals>.inner at 0x7f3804a11b10>
admin_user = <User 1>
    def test_post_invalid_partsizes(client, headers, bucket, get_json, admin_user):
        """Test invalid multipart init."""
        login_user(client, admin_user)
        # Part size too large
        res = client.post(
            obj_url(bucket),
            query_string="uploads",
            headers=headers,
            data=json.dumps({"size": 30, "partSize": 21}),
        )
>       assert res.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:108: AssertionError
____________________________ test_post_size_limits _____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
headers = {'Accept': '*/*', 'Content-Type': 'application/json'}
bucket = fe7428fe-3a54-4604-bb56-40a2eed36e6f, admin_user = <User 1>
    def test_post_size_limits(client, db, headers, bucket, admin_user):
        """Test invalid multipart init."""
        login_user(client, admin_user)
        bucket.quota_size = 100
        db.session.commit()
        # Bucket quota exceed
        res = client.post(
            obj_url(bucket),
            query_string="uploads",
            headers=headers,
            data=json.dumps({"size": 101, "partSize": 20}),
        )
>       assert res.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:143: AssertionError
___________________________ test_post_locked_bucket ____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
headers = {'Accept': '*/*', 'Content-Type': 'application/json'}
bucket = ad879368-ce9a-4f39-b0db-168591560294
get_json = <function get_json.<locals>.inner at 0x7f3804a38b40>
admin_user = <User 1>
    def test_post_locked_bucket(client, db, headers, bucket, get_json, admin_user):
        """Test invalid multipart init."""
        login_user(client, admin_user)
        bucket.locked = True
        db.session.commit()
        res = client.post(
            obj_url(bucket),
            query_string="uploads",
            headers=headers,
            data=json.dumps({"size": 10, "partSize": 2}),
        )
>       assert res.status_code == 403
E       assert 404 == 403
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:171: AssertionError
_____________________________ test_post_invalidkey _____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
headers = {'Accept': '*/*', 'Content-Type': 'application/json'}
bucket = 73b408e2-e82a-4082-9a99-849ef6e43171, admin_user = <User 1>
    def test_post_invalidkey(client, db, headers, bucket, admin_user):
        """Test invalid multipart init."""
        login_user(client, admin_user)
        object_url = (
            url_for(
                "invenio_files_rest.object_api",
                bucket_id=str(bucket.id),
                key="a" * 1025,
            )
            + "uploads"
        )
        # Bucket quota exceed
        res = client.post(
            object_url,
            query_string="uploads",
            headers=headers,
            data=json.dumps({"size": 50, "partSize": 20}),
        )
>       assert res.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:205: AssertionError
_____________________________ test_put_wrong_sizes _____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = 7266cc20-a5ee-4188-898d-04931d89f9d4
multipart = 7266cc20-a5ee-4188-898d-04931d89f9d4:16f76914-8546-44b2-a3e0-d2a6053bdb42:mykey
multipart_url = '/files/7266cc20-a5ee-4188-898d-04931d89f9d4/mykey?uploadId=16f76914-8546-44b2-a3e0-d2a6053bdb42'
admin_user = <User 1>
    def test_put_wrong_sizes(client, db, bucket, multipart, multipart_url, admin_user):
        """Test invalid part sizes."""
        login_user(client, admin_user)
        cases = [
            b"a" * (multipart.chunk_size + 1),
            b"a" * (multipart.chunk_size - 1),
            b"",
        ]
        for data in cases:
            res = client.put(
                multipart_url + "&partNumber={0}".format(1),
                input_stream=BytesIO(data),
            )
>           assert res.status_code == 400
E           assert 404 == 400
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:283: AssertionError
____________________________ test_put_ngfileupload _____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = c108a5b8-50ce-4f76-8e4d-bcac1ad359a8
multipart = c108a5b8-50ce-4f76-8e4d-bcac1ad359a8:6e2cefc3-2565-455c-bad9-49452bd78e08:mykey
multipart_url = '/files/c108a5b8-50ce-4f76-8e4d-bcac1ad359a8/mykey?uploadId=6e2cefc3-2565-455c-bad9-49452bd78e08'
admin_user = <User 1>
    def test_put_ngfileupload(client, db, bucket, multipart, multipart_url, admin_user):
        """Test invalid part sizes."""
        login_user(client, admin_user)
        res = client.put(
            multipart_url,
            data={
                "_chunkNumber": "0",
                "_currentChunkSize": str(multipart.chunk_size),
                "_chunkSize": str(multipart.chunk_size),
                "_totalSize": str(multipart.size),
                "file": (BytesIO(b"a" * multipart.chunk_size), multipart.key),
            },
        )
>       assert res.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:300: AssertionError
_________________________ test_put_invalid_part_number _________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = 2734ee2e-fac5-42b8-8ec5-1fb56dd2093c
multipart = 2734ee2e-fac5-42b8-8ec5-1fb56dd2093c:99937c59-0736-4397-9970-16bcf0112930:mykey
multipart_url = '/files/2734ee2e-fac5-42b8-8ec5-1fb56dd2093c/mykey?uploadId=99937c59-0736-4397-9970-16bcf0112930'
admin_user = <User 1>
    def test_put_invalid_part_number(
        client, db, bucket, multipart, multipart_url, admin_user
    ):
        """Test invalid part number."""
        login_user(client, admin_user)
        data = b"a" * multipart.chunk_size
        for c in [400, 2000, "a"]:
            res = client.put(
                multipart_url + "&partNumber={0}".format(c),
                input_stream=BytesIO(data),
            )
>           assert res.status_code == 400
E           assert 404 == 400
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:315: AssertionError
_________________________ test_put_completed_multipart _________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = 15e0d8d2-0c1a-4238-94d8-eaf5be12ef37
multipart = 15e0d8d2-0c1a-4238-94d8-eaf5be12ef37:bc1175e7-e844-4d09-8a0e-f9f2a5abc9ec:mykey
multipart_url = '/files/15e0d8d2-0c1a-4238-94d8-eaf5be12ef37/mykey?uploadId=bc1175e7-e844-4d09-8a0e-f9f2a5abc9ec'
admin_user = <User 1>
    def test_put_completed_multipart(
        client, db, bucket, multipart, multipart_url, admin_user
    ):
        """Test uploading to a completed multipart upload."""
        login_user(client, admin_user)
        multipart.completed = True
        db.session.commit()
        res = client.put(
            multipart_url + "&partNumber={0}".format(1),
            input_stream=BytesIO(b"a" * multipart.chunk_size),
        )
>       assert res.status_code == 403
E       assert 404 == 403
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:331: AssertionError
______________________________ test_put_badstream ______________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = 61bda313-643a-4ed0-b6d5-eb7365d44082
multipart = 61bda313-643a-4ed0-b6d5-eb7365d44082:0aa5d254-43fe-44b6-98e6-37ce6dca8e91:mykey
multipart_url = '/files/61bda313-643a-4ed0-b6d5-eb7365d44082/mykey?uploadId=0aa5d254-43fe-44b6-98e6-37ce6dca8e91'
get_json = <function get_json.<locals>.inner at 0x7f3805659fe0>
admin_user = <User 1>
    def test_put_badstream(
        client, db, bucket, multipart, multipart_url, get_json, admin_user
    ):
        """Test uploading to a completed multipart upload."""
        login_user(client, admin_user)
        client.put(
            multipart_url + "&partNumber={0}".format(1),
            input_stream=BytesIO(b"a" * multipart.chunk_size),
        )
        # Part exists
>       data = get_json(client.get(multipart_url), code=200)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_views_multipart.py:346: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
resp = <WrapperTestResponse streamed [404 NOT FOUND]>, code = 200
    def inner(resp, code=None):
        if code is not None:
>           assert resp.status_code == code
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/conftest.py:401: AssertionError
________________________________ test_get_empty ________________________________
client = <FlaskClient <Flask 'testapp'>>
multipart = 0a526499-9a29-44ff-bc0c-5eb4bec96305:9d5c014e-2239-4edf-93c5-9f2fd69431ea:mykey
multipart_url = '/files/0a526499-9a29-44ff-bc0c-5eb4bec96305/mykey?uploadId=9d5c014e-2239-4edf-93c5-9f2fd69431ea'
get_json = <function get_json.<locals>.inner at 0x7f38023c2a30>
admin_user = <User 1>
    def test_get_empty(client, multipart, multipart_url, get_json, admin_user):
        """Test get parts when empty."""
        login_user(client, admin_user)
>       data = get_json(client.get(multipart_url), code=200)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_views_multipart.py:395: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
resp = <WrapperTestResponse streamed [404 NOT FOUND]>, code = 200
    def inner(resp, code=None):
        if code is not None:
>           assert resp.status_code == code
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/conftest.py:401: AssertionError
____________________________ test_get_serialization ____________________________
client = <FlaskClient <Flask 'testapp'>>
multipart = 80371fce-0317-4375-b831-329bae15eab8:2a3cc9d5-539f-4614-bf51-324875f45586:mykey
multipart_url = '/files/80371fce-0317-4375-b831-329bae15eab8/mykey?uploadId=2a3cc9d5-539f-4614-bf51-324875f45586'
get_json = <function get_json.<locals>.inner at 0x7f380245d430>
admin_user = <User 1>
    def test_get_serialization(client, multipart, multipart_url, get_json, admin_user):
        """Test get parts when empty."""
        login_user(client, admin_user)
        client.put(
            multipart_url + "&partNumber={0}".format(1),
            input_stream=BytesIO(b"a" * multipart.chunk_size),
        )
>       data = get_json(client.get(multipart_url), code=200)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_views_multipart.py:409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
resp = <WrapperTestResponse streamed [404 NOT FOUND]>, code = 200
    def inner(resp, code=None):
        if code is not None:
>           assert resp.status_code == code
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/conftest.py:401: AssertionError
___________________________ test_post_complete_fail ____________________________
client = <FlaskClient <Flask 'testapp'>>
headers = {'Accept': '*/*', 'Content-Type': 'application/json'}
bucket = 4767dd06-768b-41b5-8ae2-3af3f542e8bd
multipart = 4767dd06-768b-41b5-8ae2-3af3f542e8bd:131f9a70-3c75-4a4d-9b8e-6beb4092bf33:mykey
multipart_url = '/files/4767dd06-768b-41b5-8ae2-3af3f542e8bd/mykey?uploadId=131f9a70-3c75-4a4d-9b8e-6beb4092bf33'
parts = [<Part 131f9a70-3c75-4a4d-9b8e-6beb4092bf33, 0>, <Part 131f9a70-3c75-4a4d-9b8e-6beb4092bf33, 1>, <Part 131f9a70-3c75-4...-9b8e-6beb4092bf33, 3>, <Part 131f9a70-3c75-4a4d-9b8e-6beb4092bf33, 4>, <Part 131f9a70-3c75-4a4d-9b8e-6beb4092bf33, 5>]
get_json = <function get_json.<locals>.inner at 0x7f3801b6e980>
admin_user = <User 1>
    def test_post_complete_fail(
        client, headers, bucket, multipart, multipart_url, parts, get_json, admin_user
    ):
        """Test completing multipart when merge fails."""
        login_user(client, admin_user)
        # Mock celery task to emulate real usage
        task_result = MagicMock()
        task_result.ready = MagicMock(side_effect=[False, False, True])
        task_result.successful = MagicMock(return_value=False)
        # Complete multipart upload
        with patch("invenio_files_rest.views.merge_multipartobject") as task:
            task.delay = MagicMock(return_value=task_result)
            res = client.post(multipart_url)
>           data = get_json(res, code=200)
                   ^^^^^^^^^^^^^^^^^^^^^^^
tests/test_views_multipart.py:516: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
resp = <WrapperTestResponse streamed [404 NOT FOUND]>, code = 200
    def inner(resp, code=None):
        if code is not None:
>           assert resp.status_code == code
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/conftest.py:401: AssertionError
__________________________ test_post_complete_timeout __________________________
app = <Flask 'testapp'>, client = <FlaskClient <Flask 'testapp'>>
headers = {'Accept': '*/*', 'Content-Type': 'application/json'}
bucket = 134e282f-183f-435f-8fc9-1dc477e910f6
multipart = 134e282f-183f-435f-8fc9-1dc477e910f6:4053e367-f2c6-46d0-97f3-80bb5135e011:mykey
multipart_url = '/files/134e282f-183f-435f-8fc9-1dc477e910f6/mykey?uploadId=4053e367-f2c6-46d0-97f3-80bb5135e011'
parts = [<Part 4053e367-f2c6-46d0-97f3-80bb5135e011, 0>, <Part 4053e367-f2c6-46d0-97f3-80bb5135e011, 1>, <Part 4053e367-f2c6-4...-97f3-80bb5135e011, 3>, <Part 4053e367-f2c6-46d0-97f3-80bb5135e011, 4>, <Part 4053e367-f2c6-46d0-97f3-80bb5135e011, 5>]
get_json = <function get_json.<locals>.inner at 0x7f3801a95fe0>
admin_user = <User 1>
    def test_post_complete_timeout(
        app, client, headers, bucket, multipart, multipart_url, parts, get_json, admin_user
    ):
        """Test completing multipart when merge fails."""
        login_user(client, admin_user)
        max_rounds = int(
            app.config["FILES_REST_TASK_WAIT_MAX_SECONDS"]
            // app.config["FILES_REST_TASK_WAIT_INTERVAL"]
        )
        # Mock celery task to emulate real usage
        task_result = MagicMock()
        task_result.ready = MagicMock(return_value=False)
        # Complete multipart upload
        with patch("invenio_files_rest.views.merge_multipartobject") as task:
            task.delay = MagicMock(return_value=task_result)
            res = client.post(multipart_url)
>           data = get_json(res, code=200)
                   ^^^^^^^^^^^^^^^^^^^^^^^
tests/test_views_multipart.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
resp = <WrapperTestResponse streamed [404 NOT FOUND]>, code = 200
    def inner(resp, code=None):
        if code is not None:
>           assert resp.status_code == code
E           assert 404 == 200
E            +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/conftest.py:401: AssertionError
_____________________ test_already_exhausted_input_stream ______________________
app = <Flask 'testapp'>, client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = 5f6cdde2-c771-4ede-970a-12715eef7b7f, admin_user = <User 1>
    def test_already_exhausted_input_stream(app, client, db, bucket, admin_user):
        """Test server error when file stream is already read."""
        key = "test.json"
        data = b'{"json": "file"}'
        object_url = url_for("invenio_files_rest.object_api", bucket_id=bucket.id, key=key)
        # Add a new before request hook which reads the incoming request payload
        # This simulates what happens when Sentry's raven-python library when it
        # reads the JSON payloads, breaking the upload of JSON files
        # (`application/json`)
        def consume_request_input_stream(*args):
            """Reads input stream object."""
            from flask import request
            request.data
        app.before_request(consume_request_input_stream)
        login_user(client, admin_user)
        resp = client.put(
            object_url,
            input_stream=BytesIO(data),
        )
>       assert resp.status_code == 500
E       assert 404 == 500
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_multipart.py:672: AssertionError
___________________________ test_get_unreadable_file ___________________________
client = <FlaskClient <Flask 'testapp'>>
headers = {'Accept': '*/*', 'Content-Type': 'application/json'}
bucket = c6f036f2-a215-4fbd-81fa-4ef11582a456
objects = [c6f036f2-a215-4fbd-81fa-4ef11582a456:d0dace58-a023-44ea-9abd-d8138f3153e2:LICENSE, c6f036f2-a215-4fbd-81fa-4ef11582a456:6a1d1277-5135-4678-a30c-e26fa74ef85e:README.rst]
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
admin_user = <User 1>
    def test_get_unreadable_file(client, headers, bucket, objects, db, admin_user):
        """Test getting an object with an unreadable file."""
        login_user(client, admin_user)
        obj = objects[0]
        assert obj.is_head
        obj.file.readable = False
        db.session.commit()
        resp = client.get(
            url_for(
                "invenio_files_rest.object_api",
                bucket_id=bucket.id,
                key=obj.key,
            )
        )
>       assert resp.status_code == 503
E       assert 404 == 503
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:195: AssertionError
______________ test_put_file_size_errors[50-100-400-Bucket quota] ______________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = eddc6c97-58f5-431a-85e3-8e16cb71ba8f, quota_size = 50
max_file_size = 100, expected = 400, err = 'Bucket quota', admin_user = <User 1>
    @pytest.mark.parametrize(
        "quota_size, max_file_size, expected, err",
        [
            (50, 100, 400, "Bucket quota"),
            (100, 50, 400, "Maximum file size"),
            (100, 100, 200, None),
            (None, None, 200, None),
        ],
    )
    def test_put_file_size_errors(
        client, db, bucket, quota_size, max_file_size, expected, err, admin_user
    ):
        """Test that file size errors are properly raised."""
        login_user(client, admin_user)
        filedata = b"a" * 75
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        # Set quota and max file size
        bucket.quota_size = quota_size
        bucket.max_file_size = max_file_size
        db.session.commit()
        # Test set limits
        resp = client.put(object_url, input_stream=BytesIO(filedata))
>       assert resp.status_code == expected
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:376: AssertionError
___________ test_put_file_size_errors[100-50-400-Maximum file size] ____________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = dc4b89e0-9fb6-47ff-ad5c-0cd74a6b512c, quota_size = 100
max_file_size = 50, expected = 400, err = 'Maximum file size'
admin_user = <User 1>
    @pytest.mark.parametrize(
        "quota_size, max_file_size, expected, err",
        [
            (50, 100, 400, "Bucket quota"),
            (100, 50, 400, "Maximum file size"),
            (100, 100, 200, None),
            (None, None, 200, None),
        ],
    )
    def test_put_file_size_errors(
        client, db, bucket, quota_size, max_file_size, expected, err, admin_user
    ):
        """Test that file size errors are properly raised."""
        login_user(client, admin_user)
        filedata = b"a" * 75
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        # Set quota and max file size
        bucket.quota_size = quota_size
        bucket.max_file_size = max_file_size
        db.session.commit()
        # Test set limits
        resp = client.put(object_url, input_stream=BytesIO(filedata))
>       assert resp.status_code == expected
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:376: AssertionError
_________________ test_put_file_size_errors[100-100-200-None] __________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = 0cc4cca3-0c45-4ced-95db-d89e5d37ba1d, quota_size = 100
max_file_size = 100, expected = 200, err = None, admin_user = <User 1>
    @pytest.mark.parametrize(
        "quota_size, max_file_size, expected, err",
        [
            (50, 100, 400, "Bucket quota"),
            (100, 50, 400, "Maximum file size"),
            (100, 100, 200, None),
            (None, None, 200, None),
        ],
    )
    def test_put_file_size_errors(
        client, db, bucket, quota_size, max_file_size, expected, err, admin_user
    ):
        """Test that file size errors are properly raised."""
        login_user(client, admin_user)
        filedata = b"a" * 75
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        # Set quota and max file size
        bucket.quota_size = quota_size
        bucket.max_file_size = max_file_size
        db.session.commit()
        # Test set limits
        resp = client.put(object_url, input_stream=BytesIO(filedata))
>       assert resp.status_code == expected
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:376: AssertionError
________________ test_put_file_size_errors[None-None-200-None] _________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = ddf4037e-c644-426d-b0ec-95fb187f1e28, quota_size = None
max_file_size = None, expected = 200, err = None, admin_user = <User 1>
    @pytest.mark.parametrize(
        "quota_size, max_file_size, expected, err",
        [
            (50, 100, 400, "Bucket quota"),
            (100, 50, 400, "Maximum file size"),
            (100, 100, 200, None),
            (None, None, 200, None),
        ],
    )
    def test_put_file_size_errors(
        client, db, bucket, quota_size, max_file_size, expected, err, admin_user
    ):
        """Test that file size errors are properly raised."""
        login_user(client, admin_user)
        filedata = b"a" * 75
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        # Set quota and max file size
        bucket.quota_size = quota_size
        bucket.max_file_size = max_file_size
        db.session.commit()
        # Test set limits
        resp = client.put(object_url, input_stream=BytesIO(filedata))
>       assert resp.status_code == expected
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:376: AssertionError
_____________________________ test_put_invalid_key _____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = cffb2cc5-a4de-42da-a921-fa248ed90ee1, admin_user = <User 1>
    def test_put_invalid_key(client, db, bucket, admin_user):
        login_user(client, admin_user)
        """Test invalid key name."""
        key = "a" * 2000
        object_url = url_for("invenio_files_rest.object_api", bucket_id=bucket.id, key=key)
        # Test set limits
        resp = client.put(object_url, input_stream=BytesIO(b"test"))
>       assert resp.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:397: AssertionError
______________________________ test_put_zero_size ______________________________
client = <FlaskClient <Flask 'testapp'>>
bucket = 940dfe55-8667-4360-947e-c070d8ad7ba1, admin_user = <User 1>
    def test_put_zero_size(client, bucket, admin_user):
        """Test zero size file."""
        login_user(client, admin_user)
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        # Test set limits
        resp = client.put(object_url, input_stream=BytesIO(b""))
>       assert resp.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:410: AssertionError
___________________________ test_put_deleted_locked ____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = e6c084a3-a61c-4579-a60a-fb19de2918be, admin_user = <User 1>
    def test_put_deleted_locked(client, db, bucket, admin_user):
        """Test that file size errors are properly raised."""
        login_user(client, admin_user)
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        # Can upload
        resp = client.put(object_url, input_stream=BytesIO(b"test"))
>       assert resp.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:423: AssertionError
________________________________ test_put_error ________________________________
client = <FlaskClient <Flask 'testapp'>>
bucket = 64eb20e5-8831-4e3d-b4be-73838c5c78b4, admin_user = <User 1>
    def test_put_error(client, bucket, admin_user):
        """Test upload - cancelled by user."""
        login_user(client, admin_user)
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        response = client.put(object_url, input_stream=BadBytesIO(b"a" * 128))
>       assert response.status_code == 400
E       assert 404 == 400
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:447: AssertionError
____________________________ test_put_multipartform ____________________________
client = <FlaskClient <Flask 'testapp'>>
bucket = 5bbcdb90-16a0-45be-b29d-9bd877c11bb7, admin_user = <User 1>
    def test_put_multipartform(client, bucket, admin_user):
        """Test upload via multipart/form-data."""
        login_user(client, admin_user)
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key="test.txt"
        )
        res = client.put(
            object_url,
            data={
                "_chunkNumber": "0",
                "_currentChunkSize": "100",
                "_chunkSize": "10000000",
                "_totalSize": "100",
                "file": (BytesIO(b"a" * 100), "test.txt"),
            },
        )
>       assert res.status_code == 200
E       assert 404 == 200
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:474: AssertionError
_______________________ test_delete_versions_head_reset ________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = bc958985-6f9c-4e45-9d0b-c1238378e8c9
versions = [bc958985-6f9c-4e45-9d0b-c1238378e8c9:78dd07b9-38e6-4439-b62b-eee1e71d1954:LICENSE, bc958985-6f9c-4e45-9d0b-c1238378e8...b09-8375-ec40242b8247:README.rst, bc958985-6f9c-4e45-9d0b-c1238378e8c9:8db0bb63-ece9-41eb-aca8-518066f88e8e:README.rst]
admin_user = <User 1>
    def test_delete_versions_head_reset(client, db, bucket, versions, admin_user):
        """Test head setting after deletion."""
        login_user(client, admin_user)
        key = "LICENSE"
        versions_to_delete = [version for version in versions if version.key == key]
        assert len(versions_to_delete) == 2
        for obj in versions_to_delete:
            if obj.is_head:
                version_to_delete = obj
            else:
                new_head_obj = obj
        assert not new_head_obj.is_head
        res = client.delete(
            url_for(
                "invenio_files_rest.object_api",
                bucket_id=bucket.id,
                key=version_to_delete.key,
                versionId=version_to_delete.version_id,
            )
        )
>       assert res.status_code == 204
E       assert 404 == 204
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:587: AssertionError
__________________________ test_delete_locked_deleted __________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = 07ef457b-b6c5-4d8e-9af7-71205c6b3476
versions = [07ef457b-b6c5-4d8e-9af7-71205c6b3476:13e52185-9d31-4456-9d70-8ea2972754c9:LICENSE, 07ef457b-b6c5-4d8e-9af7-71205c6b34...71f-8828-918e0896d704:README.rst, 07ef457b-b6c5-4d8e-9af7-71205c6b3476:4c7de265-ac84-46be-8e9a-0923b0b725a9:README.rst]
admin_user = <User 1>
    def test_delete_locked_deleted(client, db, bucket, versions, admin_user):
        """Test a deleted/locked bucket."""
        obj = versions[0]
        object_url = url_for(
            "invenio_files_rest.object_api", bucket_id=bucket.id, key=obj.key
        )
        # Locked bucket
        bucket.locked = True
        db.session.commit()
        login_user(client, admin_user)
        # Latest version
        resp = client.delete(object_url)
>       assert resp.status_code == 403
E       assert 404 == 403
E        +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
tests/test_views_objectversion.py:606: AssertionError
____________________________ test_delete_unwritable ____________________________
client = <FlaskClient <Flask 'testapp'>>
db = <SQLAlchemy postgresql+psycopg2://invenio:***@localhost:5432/invenio>
bucket = be2c539e-868a-4f3d-aaf4-daee81527e87
versions = [be2c539e-868a-4f3d-aaf4-daee81527e87:744fbcec-d5f9-4284-89b1-878aac2cb39f:LICENSE, be2c539e-868a-4f3d-aaf4-daee81527e...807-b0a0-7e899a5c5b2d:README.rst, be2c539e-868a-4f3d-aaf4-daee81527e87:52087a35-15cb-4e1c-ba66-ec16798cea00:README.rst]
admin_user = <User 1>
    def test_delete_unwritable(client, db, bucket, versions, admin_user):
        """Test deleting a file which is not writable."""
        obj = versions[0]
        # Unwritable file
        obj.file.writable = False
        db.session.commit()
        login_user(client, admin_user)
        # Delete specific version
        with patch("invenio_files_rest.views.remove_file_data") as task:
            resp = client.delete(
                url_for(
                    "invenio_files_rest.object_api",
                    bucket_id=bucket.id,
                    key=obj.key,
                    versionId=obj.version_id,
                ),
            )
>           assert task.delay.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='remove_file_data.delay' id='139878602961456'>.called
E            +    where <MagicMock name='remove_file_data.delay' id='139878602961456'> = <MagicMock name='remove_file_data' id='139878563795296'>.delay
tests/test_views_objectversion.py:646: AssertionError
=============================== warnings summary ===============================
venv/lib/python3.14/site-packages/webargs/compat.py:8
    MARSHMALLOW_VERSION_INFO = tuple(LooseVersion(ma.__version__).version)  # type: tuple
venv/lib/python3.14/site-packages/webargs/compat.py:8
    MARSHMALLOW_VERSION_INFO = tuple(LooseVersion(ma.__version__).version)  # type: tuple
venv/lib/python3.14/site-packages/webargs/__init__.py:13
    __version_info__ = tuple(LooseVersion(__version__).version)
venv/lib/python3.14/site-packages/flask_admin/contrib/__init__.py:2
    __import__('pkg_resources').declare_namespace(__name__)
venv/lib/python3.14/site-packages/pkg_resources/__init__.py:3148
venv/lib/python3.14/site-packages/pkg_resources/__init__.py:3148
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)
venv/lib/python3.14/site-packages/flask_admin/contrib/__init__.py:2
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    __import__('pkg_resources').declare_namespace(__name__)
venv/lib/python3.14/site-packages/pkg_resources/__init__.py:2560
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(parent)
    warnings.warn(
  /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-files-rest/original/invenio_files_rest/models.py:719: SAWarning: Object of type <ObjectVersion> not in session, add operation along 'Bucket.objects' will not proceed (This warning originated from the Session 'autoflush' process, which was invoked automatically in response to a user-initiated operation. Consider using ``no_autoflush`` context manager if this warning happened while initializing objects.)
    return db.session.query(cls).filter_by(id=file_id).one_or_none()
tests/test_invenio_files_rest.py::test_alembic
    util.warn_deprecated(
tests/test_invenio_files_rest.py::test_alembic
    super().alter_column(
tests/test_invenio_files_rest.py::test_alembic
    insp = Inspector.from_engine(ctx.connection.engine)
tests/test_views_objectversion.py::test_get_with_x_sendfile
    warnings.warn("This streaming does not support multiple storage backends.")
invenio_files_rest/__init__.py::invenio_files_rest
    self.init_app(app)
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.14.2-final-0 ________________
Name                                                                                  Stmts   Miss  Cover   Missing
invenio_files_rest/__init__.py                                                            4      0   100%
invenio_files_rest/admin.py                                                             116     13    89%   338-354
invenio_files_rest/alembic/2e97565eba72_create_files_rest_tables.py                      34      0   100%
invenio_files_rest/alembic/8ae99b034410_create_files_objecttags_table.py                 22      3    86%   28-29, 67
invenio_files_rest/alembic/08e4a71525b6_change_datetime_types.py                         15      0   100%
invenio_files_rest/alembic/52ce868f33c3_create_files_rest_branch.py                       8      0   100%
invenio_files_rest/alembic/a29271fd78f8_create_files_object_partial_unique_index.py      12      0   100%
invenio_files_rest/alembic/e172c837b036_add_indexes.py                                   21      0   100%
invenio_files_rest/alembic/f741aa746a7d_alter_files_files_last_check_column_to_.py       10      0   100%
invenio_files_rest/app.py                                                                 4      0   100%
invenio_files_rest/cli.py                                                                66      0   100%
invenio_files_rest/config.py                                                             52      0   100%
invenio_files_rest/errors.py                                                             63      6    90%   28-30, 54-55, 59
invenio_files_rest/ext.py                                                                52      5    90%   76-78, 86-87
invenio_files_rest/formparser.py                                                         24      7    71%   35, 39, 54, 65, 69-71
invenio_files_rest/helpers.py                                                           118      5    96%   183-187
invenio_files_rest/limiters.py                                                           25      0   100%
invenio_files_rest/models.py                                                            704     32    95%   117, 372, 542-547, 711, 1021-1023, 1254, 1405, 1463, 1628-1635, 1641, 1675, 1679, 1683, 1688-1693, 1732-1735, 1786, 1812, 1818
invenio_files_rest/permissions.py                                                        61      1    98%   134
invenio_files_rest/proxies.py                                                             6      0   100%
invenio_files_rest/serializer.py                                                        123      4    97%   261, 270, 304, 337
invenio_files_rest/signals.py                                                             8      0   100%
invenio_files_rest/storage/__init__.py                                                    3      0   100%
invenio_files_rest/storage/base.py                                                       91      2    98%   120-121
invenio_files_rest/storage/pyfs.py                                                      127     12    91%   58, 79, 91, 105-106, 117, 127, 139, 231-234
invenio_files_rest/tasks.py                                                             123     19    85%   108-109, 118, 241-243, 259, 261, 268-270, 276-285
invenio_files_rest/utils.py                                                              20      1    95%   35
invenio_files_rest/views.py                                                             273     24    91%   63, 196, 239, 290-293, 337, 636-641, 726, 769-775, 808, 815-821, 927, 930
invenio_files_rest/wrappers.py                                                            4      0   100%
TOTAL                                                                                  2189    134    94%
=========================== short test summary info ============================
FAILED tests/test_views_multipart.py::test_post_invalid_partsizes - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_post_size_limits - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_post_locked_bucket - assert 404 == 403
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_post_invalidkey - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_put_wrong_sizes - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_put_ngfileupload - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_put_invalid_part_number - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_put_completed_multipart - assert 404 == 403
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_put_badstream - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_get_empty - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_get_serialization - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_post_complete_fail - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_post_complete_timeout - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_multipart.py::test_already_exhausted_input_stream - assert 404 == 500
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_get_unreadable_file - assert 404 == 503
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_file_size_errors[50-100-400-Bucket quota] - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_file_size_errors[100-50-400-Maximum file size] - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_file_size_errors[100-100-200-None] - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_file_size_errors[None-None-200-None] - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_invalid_key - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_zero_size - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_deleted_locked - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_error - assert 404 == 400
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_put_multipartform - assert 404 == 200
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_delete_versions_head_reset - assert 404 == 204
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_delete_locked_deleted - assert 404 == 403
 +  where 404 = <WrapperTestResponse streamed [404 NOT FOUND]>.status_code
FAILED tests/test_views_objectversion.py::test_delete_unwritable - AssertionError: assert False
 +  where False = <MagicMock name='remove_file_data.delay' id='139878602961456'>.called
 +    where <MagicMock name='remove_file_data.delay' id='139878602961456'> = <MagicMock name='remove_file_data' id='139878563795296'>.delay
ERROR tests/test_views_multipart.py::test_post_init[objects-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_multipart.py::test_post_init[bucket-200] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_multipart.py::test_post_init[location-200] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_multipart.py::test_post_init_querystring - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_get_not_found[None-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_get_not_found[auth-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_get_not_found[objects-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_post[auth-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_post[bucket-403] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_post[location-403] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_put[None-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_put[auth-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_put[objects-404] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_put[bucket-200] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
ERROR tests/test_views_objectversion.py::test_put[location-200] - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (::1), port 5432 failed: Connection refused
	Is the server running on that host and accepting TCP/IP connections?
connection to server at "localhost" (127.0.0.1), port 5432 failed: FATAL:  sorry, too many clients already
(Background on this error at: https://sqlalche.me/e/20/e3q8)
====== 27 failed, 179 passed, 40 warnings, 15 errors in 89.78s (0:01:29) =======
 Container docker_services_cli-opensearch-1  Stopping
 Container docker_services_cli-redis-1  Stopping
 Container docker_services_cli-postgresql-1  Stopping
 Container docker_services_cli-rabbitmq-1  Stopping
 Container docker_services_cli-redis-1  Stopped
 Container docker_services_cli-redis-1  Removing
 Container docker_services_cli-redis-1  Removed
 Container docker_services_cli-opensearch-1  Stopped
 Container docker_services_cli-opensearch-1  Removing
 Container docker_services_cli-opensearch-1  Removed
 Container docker_services_cli-postgresql-1  Stopped
 Container docker_services_cli-postgresql-1  Removing
 Container docker_services_cli-postgresql-1  Removed
 Container docker_services_cli-rabbitmq-1  Stopped
 Container docker_services_cli-rabbitmq-1  Removing
 Container docker_services_cli-rabbitmq-1  Removed
 Network docker_services_cli_default  Removing
 Network docker_services_cli_default  Removed
