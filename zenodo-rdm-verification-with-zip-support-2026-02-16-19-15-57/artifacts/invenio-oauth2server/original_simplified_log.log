running extract_messages
extracting messages from invenio_oauth2server/__init__.py (encoding="utf-8")
extracting messages from invenio_oauth2server/admin.py (encoding="utf-8")
extracting messages from invenio_oauth2server/cli.py (encoding="utf-8")
extracting messages from invenio_oauth2server/config.py (encoding="utf-8")
extracting messages from invenio_oauth2server/decorators.py (encoding="utf-8")
extracting messages from invenio_oauth2server/errors.py (encoding="utf-8")
extracting messages from invenio_oauth2server/ext.py (encoding="utf-8")
extracting messages from invenio_oauth2server/forms.py (encoding="utf-8")
extracting messages from invenio_oauth2server/models.py (encoding="utf-8")
extracting messages from invenio_oauth2server/provider.py (encoding="utf-8")
extracting messages from invenio_oauth2server/proxies.py (encoding="utf-8")
extracting messages from invenio_oauth2server/scopes.py (encoding="utf-8")
extracting messages from invenio_oauth2server/utils.py (encoding="utf-8")
extracting messages from invenio_oauth2server/validators.py (encoding="utf-8")
extracting messages from invenio_oauth2server/alembic/12a88921ada2_create_oauth2server_tables.py (encoding="utf-8")
extracting messages from invenio_oauth2server/alembic/4e57407b8e4a_add_on_delete_cascade.py (encoding="utf-8")
extracting messages from invenio_oauth2server/alembic/aa546f2a8d2f_create_oauth2server_branch.py (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/authorize.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/base.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/errors.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/_macros.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/base.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/client_new.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/client_view.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/helpers.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/index.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/token_new.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/token_permission_view.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/invenio_oauth2server/settings/token_view.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/authorize.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/base.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/errors.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/_macros.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/base.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/client_new.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/client_view.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/helpers.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/index.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/token_new.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/token_permission_view.html (encoding="utf-8")
extracting messages from invenio_oauth2server/templates/semantic-ui/invenio_oauth2server/settings/token_view.html (encoding="utf-8")
extracting messages from invenio_oauth2server/theme/semantic/form_styling.py (encoding="utf-8")
extracting messages from invenio_oauth2server/views/__init__.py (encoding="utf-8")
extracting messages from invenio_oauth2server/views/server.py (encoding="utf-8")
extracting messages from invenio_oauth2server/views/settings.py (encoding="utf-8")
writing PO template file to /dev/null
 postgresql Pulling 
 postgresql Pulled 
 Network docker_services_cli_default  Creating
 Network docker_services_cli_default  Created
 Container docker_services_cli-postgresql-1  Creating
 Container docker_services_cli-postgresql-1  Created
 Container docker_services_cli-postgresql-1  Starting
 Container docker_services_cli-postgresql-1  Started
============================= test session starts ==============================
platform linux -- Python 3.14.2, pytest-8.4.2, pluggy-1.6.0
rootdir: /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original
configfile: setup.cfg
testpaths: tests, invenio_oauth2server
plugins: isort-4.0.0, flask-1.3.0, black-ng-0.4.1, invenio-3.4.2, github-actions-annotate-failures-0.3.0, pydocstyle-2.4.0, cov-7.0.0, pycodestyle-2.5.0
collected 61 items
tests/test_admin.py 
                                                    [  1%]
tests/test_alembic.py s                                                  [  3%]
tests/test_cli.py 
                                                      [  4%]
tests/test_decorators.py 
                                       [ 19%]
tests/test_invenio_oauth2server.py ....                                  [ 26%]
tests/test_models.py 
                                            [ 39%]
tests/test_provider.py 
::error file=workdir/tests/invenio-oauth2server/original/tests/test_provider.py,line=223::test_refresh_flow%0A%0ATypeError: can't compare offset-naive and offset-aware datetimes
F
::error file=workdir/tests/invenio-oauth2server/original/tests/test_provider.py,line=385::test_implicit_flow%0A%0ATypeError: can't compare offset-naive and offset-aware datetimes
F
::error file=workdir/tests/invenio-oauth2server/original/tests/test_provider.py,line=433::test_client_flow%0A%0ATypeError: can't compare offset-naive and offset-aware datetimes
F
::error file=workdir/tests/invenio-oauth2server/original/tests/test_provider.py,line=739::test_info_not_accessible_in_production%0A%0Aassert 500 == 404%0A +  where 500 = <WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]>.status_code
F
::error file=workdir/tests/invenio-oauth2server/original/tests/test_provider.py,line=793::test_expired_refresh_flow%0A%0ATypeError: can't compare offset-naive and offset-aware datetimes
F
::error file=workdir/tests/invenio-oauth2server/original/tests/test_provider.py,line=897::test_not_allowed_public_refresh_flow%0A%0ATypeError: can't compare offset-naive and offset-aware datetimes
F
                         [ 80%]
tests/test_server.py 
                                                   [ 81%]
tests/test_settings.py 
                                               [ 86%]
tests/test_utils.py 
                                                    [ 88%]
tests/test_validators.py .......                                         [100%]
=================================== FAILURES ===================================
______________________________ test_refresh_flow _______________________________
provider_fixture = <Flask 'testapp'>
    def test_refresh_flow(provider_fixture):
        app = provider_fixture
        with app.test_request_context():
            base_url = "https://{0}".format(app.config["SERVER_NAME"])
            redirect_uri = url_for("oauth2test.authorized", _external=True)
            with app.test_client() as client:
                # First login on provider site
                login(client)
                data = dict(
                    redirect_uri=redirect_uri,
                    scope="test:scope",
                    response_type="code",
                    client_id="confidential",
                    state="mystate",
                )
                r = client.get(url_for("invenio_oauth2server.authorize", **data))
                assert r.status_code == 200
                data["confirm"] = "yes"
                data["scope"] = "test:scope"
                data["state"] = "mystate"
                # Obtain one time code
                r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                r.status_code == 302
                next_url, res_data = parse_redirect(r.location)
                assert res_data["code"]
                assert res_data["state"] == ["mystate"]
                # Exchange one time code for access token
                r = client.post(
                    url_for("invenio_oauth2server.access_token"),
                    data=dict(
                        client_id="confidential",
                        client_secret="confidential",
                        grant_type="authorization_code",
                        code=res_data["code"],
                    ),
                )
                assert r.status_code == 200
                json_resp = json.loads(r.get_data())
                assert json_resp["access_token"]
                assert json_resp["refresh_token"]
                assert json_resp["scope"] == "test:scope"
                assert json_resp["token_type"] == "Bearer"
                assert json_resp["user"]["id"]
                refresh_token = json_resp["refresh_token"]
                old_access_token = json_resp["access_token"]
                # Access token valid
>               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=old_access_token)
                )
tests/test_provider.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/testing.py:235: in open
    response = super().open(
venv/lib/python3.14/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = <flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7ff587fe81a0>
token = 'FiuoAhUzAFsdNLGfUY993nofSJdPIS', scopes = ('test:scope',)
request = <oauthlib.Request SANITIZED>
    def validate_bearer_token(self, token, scopes, request):
        """Validate access token
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
        The validation validates:
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
        # validate expires
        if tok.expires is not None and \
>               datetime.datetime.now(datetime.timezone.utc) > tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError
______________________________ test_implicit_flow ______________________________
provider_fixture = <Flask 'testapp'>
    def test_implicit_flow(provider_fixture):
        app = provider_fixture
        with app.test_request_context():
            redirect_uri = url_for("oauth2test.authorized", _external=True)
            with app.test_client() as client:
                # First login on provider site
                login(client)
                for client_id in ["dev", "confidential"]:
                    data = dict(
                        redirect_uri=redirect_uri,
                        response_type="token",  # For implicit grant type
                        client_id=client_id,
                        scope="test:scope",
                        state="teststate",
                    )
                    # Authorize page
                    r = client.get(
                        url_for("invenio_oauth2server.authorize", **data),
                        follow_redirects=True,
                    )
                    assert r.status_code == 200
                    # User confirms request
                    data["confirm"] = "yes"
                    data["scope"] = "test:scope"
                    data["state"] = "teststate"
                    r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                    assert r.status_code == 302
                    # Important - access token exists in URI fragment and must not
                    # be sent to the client
                    next_url, data = parse_redirect(r.location, parse_fragment=True)
                    assert data["access_token"]
                    assert data["token_type"] == ["Bearer"]
                    assert data["state"] == ["teststate"]
                    assert data["scope"] == ["test:scope"]
                    assert data.get("refresh_token") is None
                    assert next_url == redirect_uri
                    # Authentication flow has now been completed, and the client
                    # can use the access token to make request to the provider
>                   r = client.get(
                        url_for(
                            "invenio_oauth2server.info", access_token=data["access_token"]
                        )
                    )
tests/test_provider.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/testing.py:235: in open
    response = super().open(
venv/lib/python3.14/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = <flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7ff587fe81a0>
token = '4TBhTpgsPMPtDdoA8VHeimt0fUScUA', scopes = ('test:scope',)
request = <oauthlib.Request SANITIZED>
    def validate_bearer_token(self, token, scopes, request):
        """Validate access token
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
        The validation validates:
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
        # validate expires
        if tok.expires is not None and \
>               datetime.datetime.now(datetime.timezone.utc) > tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError
_______________________________ test_client_flow _______________________________
provider_fixture = <Flask 'testapp'>
    def test_client_flow(provider_fixture):
        app = provider_fixture
        with app.test_request_context():
            with app.test_client() as client:
                data = dict(
                    client_id="dev",
                    client_secret="dev",  # A public client should NOT do this!
                    grant_type="client_credentials",
                    scope="test:scope",
                )
                # Public clients are not allowed to use
                # grant_type=client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 401
                assert json.loads(r.get_data()).get("error") == "invalid_client"
                data = dict(
                    client_id="confidential",
                    client_secret="confidential",
                    grant_type="client_credentials",
                    scope="test:scope",
                )
                # Retrieve access token using client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 200
                data = json.loads(r.get_data())
                assert data["access_token"]
                assert data["token_type"] == "Bearer"
                assert data["scope"] == "test:scope"
                assert data["user"]["id"]
                assert data.get("refresh_token") is None
                # Authentication flow has now been completed, and the client can
                # use the access token to make request to the provider
>               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=data["access_token"])
                )
tests/test_provider.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/testing.py:235: in open
    response = super().open(
venv/lib/python3.14/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = <flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7ff587fe81a0>
token = 'zHiYGtGZtMmlqcT3cNoFm4Zimfd0p9', scopes = ('test:scope',)
request = <oauthlib.Request SANITIZED>
    def validate_bearer_token(self, token, scopes, request):
        """Validate access token
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
        The validation validates:
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
        # validate expires
        if tok.expires is not None and \
>               datetime.datetime.now(datetime.timezone.utc) > tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError
____________________ test_info_not_accessible_in_production ____________________
provider_fixture = <Flask 'testapp'>
    def test_info_not_accessible_in_production(provider_fixture):
        """Info route should not be available in production mode."""
        app = provider_fixture
        with app.test_request_context():
            with app.test_client() as client:
                app.config.update(
                    DEBUG=False,
                    TESTING=False,
                )
                data = dict(
                    client_id="dev",
                    client_secret="dev",  # A public client should NOT do this!
                    grant_type="client_credentials",
                    scope="test:scope",
                )
                # Public clients are not allowed to use
                # grant_type=client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 401
                assert json.loads(r.get_data()).get("error") == "invalid_client"
                data = dict(
                    client_id="confidential",
                    client_secret="confidential",
                    grant_type="client_credentials",
                    scope="test:scope",
                )
                # Retrieve access token using client_credentials
                r = client.post(url_for("invenio_oauth2server.access_token"), data=data)
                assert r.status_code == 200
                data = json.loads(r.get_data())
                assert data["access_token"]
                assert data["token_type"] == "Bearer"
                assert data["scope"] == "test:scope"
                assert data.get("refresh_token") is None
                assert data["user"]["id"]
                # Authentication flow has now been completed, and the client can
                # use the access token to make request to the provider
                r = client.get(
                    url_for("invenio_oauth2server.info", access_token=data["access_token"])
                )
>               assert r.status_code == 404
E               assert 500 == 404
E                +  where 500 = <WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]>.status_code
tests/test_provider.py:739: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    testapp:app.py:875 Exception on /oauth/info [GET]
Traceback (most recent call last):
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask/app.py", line 1511, in wsgi_app
    response = self.full_dispatch_request()
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask/app.py", line 919, in full_dispatch_request
    rv = self.handle_user_exception(e)
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask/app.py", line 917, in full_dispatch_request
    rv = self.dispatch_request()
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask/app.py", line 902, in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py", line 607, in decorated
    valid, req = self.verify_request(scopes)
                 ~~~~~~~~~~~~~~~~~~~^^^^^^^^
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py", line 534, in verify_request
    return self.server.verify_request(
           ~~~~~~~~~~~~~~~~~~~~~~~~~~^
        uri, http_method, body, headers, scopes
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py", line 112, in wrapper
    return f(endpoint, uri, *args, **kwargs)
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py", line 72, in verify_request
    return token_type_handler.validate_request(request), request
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/tokens.py", line 337, in validate_request
    return self.request_validator.validate_bearer_token(
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
        token, request.scopes, request)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py", line 864, in validate_bearer_token
    datetime.datetime.now(datetime.timezone.utc) > tok.expires:
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: can't compare offset-naive and offset-aware datetimes
__________________________ test_expired_refresh_flow ___________________________
provider_fixture = <Flask 'testapp'>
    def test_expired_refresh_flow(provider_fixture):
        """Test refresh flow with an expired token."""
        app = provider_fixture
        # First login on provider site
        with app.test_request_context():
            with app.test_client() as client:
                login(client)
                data = dict(
                    redirect_uri=url_for("oauth2test.authorized", _external=True),
                    scope="test:scope",
                    response_type="code",
                    client_id="confidential",
                    state="mystate",
                )
                r = client.get(url_for("invenio_oauth2server.authorize", **data))
                assert r.status_code == 200
                data["confirm"] = "yes"
                data["scope"] = "test:scope"
                data["state"] = "mystate"
                # Obtain one time code
                r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                assert r.status_code == 302
                next_url, res_data = parse_redirect(r.location)
                assert res_data["code"]
                assert res_data["state"] == ["mystate"]
                # Exchange one time code for access token
                r = client.post(
                    url_for("invenio_oauth2server.access_token"),
                    data=dict(
                        client_id="confidential",
                        client_secret="confidential",
                        grant_type="authorization_code",
                        code=res_data["code"],
                    ),
                )
                assert r.status_code == 200
                assert json.loads(r.get_data())["access_token"]
                assert json.loads(r.get_data())["refresh_token"]
                assert json.loads(r.get_data())["expires_in"] > 0
                assert json.loads(r.get_data())["scope"] == "test:scope"
                assert json.loads(r.get_data())["token_type"] == "Bearer"
                assert json.loads(r.get_data())["user"]["id"]
                refresh_token = json.loads(r.get_data())["refresh_token"]
                old_access_token = json.loads(r.get_data())["access_token"]
                # Access token valid
>               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=old_access_token)
                )
tests/test_provider.py:793: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/testing.py:235: in open
    response = super().open(
venv/lib/python3.14/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = <flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7ff587fe81a0>
token = 'DPv3kO0lzpoWsq6AP7LIaJjcdOQhk5', scopes = ('test:scope',)
request = <oauthlib.Request SANITIZED>
    def validate_bearer_token(self, token, scopes, request):
        """Validate access token
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
        The validation validates:
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
        # validate expires
        if tok.expires is not None and \
>               datetime.datetime.now(datetime.timezone.utc) > tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError
_____________________ test_not_allowed_public_refresh_flow _____________________
provider_fixture = <Flask 'testapp'>
    def test_not_allowed_public_refresh_flow(provider_fixture):
        """Public token should not allow refreshing."""
        app = provider_fixture
        # First login on provider site
        with app.test_request_context():
            with app.test_client() as client:
                login(client)
                data = dict(
                    redirect_uri=url_for("oauth2test.authorized", _external=True),
                    scope="test:scope",
                    response_type="code",
                    client_id="dev",
                    state="mystate",
                )
                r = client.get(url_for("invenio_oauth2server.authorize", **data))
                assert r.status_code == 200
                data["confirm"] = "yes"
                data["scope"] = "test:scope"
                data["state"] = "mystate"
                # Obtain one time code
                r = client.post(url_for("invenio_oauth2server.authorize"), data=data)
                assert r.status_code == 302
                next_url, res_data = parse_redirect(r.location)
                assert res_data["code"]
                assert res_data["state"] == ["mystate"]
                # Exchange one time code for access token
                r = client.post(
                    url_for("invenio_oauth2server.access_token"),
                    data=dict(
                        client_id="dev",
                        client_secret="dev",
                        grant_type="authorization_code",
                        code=res_data["code"],
                    ),
                )
                assert r.status_code == 200
                json_resp = json.loads(r.get_data())
                assert json_resp["access_token"]
                assert json_resp["refresh_token"]
                assert json_resp["expires_in"] > 0
                assert json_resp["scope"] == "test:scope"
                assert json_resp["token_type"] == "Bearer"
                assert json_resp["user"]["id"]
                refresh_token = json_resp["refresh_token"]
                old_access_token = json_resp["access_token"]
                # Access token valid
>               r = client.get(
                    url_for("invenio_oauth2server.info", access_token=old_access_token)
                )
tests/test_provider.py:897: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.14/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/testing.py:235: in open
    response = super().open(
venv/lib/python3.14/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1536: in __call__
    return self.wsgi_app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/werkzeug/middleware/dispatcher.py:81: in __call__
    return app(environ, start_response)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1514: in wsgi_app
    response = self.handle_exception(e)
               ^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:1511: in wsgi_app
    response = self.full_dispatch_request()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:919: in full_dispatch_request
    rv = self.handle_user_exception(e)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:917: in full_dispatch_request
    rv = self.dispatch_request()
         ^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask/app.py:902: in dispatch_request
    return self.ensure_sync(self.view_functions[rule.endpoint])(**view_args)  # type: ignore[no-any-return]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:607: in decorated
    valid, req = self.verify_request(scopes)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:534: in verify_request
    return self.server.verify_request(
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/base.py:112: in wrapper
    return f(endpoint, uri, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/endpoints/resource.py:72: in verify_request
    return token_type_handler.validate_request(request), request
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv/lib/python3.14/site-packages/oauthlib/oauth2/rfc6749/tokens.py:337: in validate_request
    return self.request_validator.validate_bearer_token(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = <flask_oauthlib.provider.oauth2.OAuth2RequestValidator object at 0x7ff587fe81a0>
token = 'XnlMtOsKZVRBem2Qak4cs07cEeWaN6', scopes = ('test:scope',)
request = <oauthlib.Request SANITIZED>
    def validate_bearer_token(self, token, scopes, request):
        """Validate access token
        :param token: A string of random characters
        :param scopes: A list of scopes
        :param request: The Request object passed by oauthlib
        The validation validates:
            1) if the token is available
            2) if the token has expired
            3) if the scopes are available
        """
        log.debug('Validate bearer token %r', token)
        tok = self._tokengetter(access_token=token)
        if not tok:
            msg = 'Bearer token not found.'
            request.error_message = msg
            log.debug(msg)
            return False
        # validate expires
        if tok.expires is not None and \
>               datetime.datetime.now(datetime.timezone.utc) > tok.expires:
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: can't compare offset-naive and offset-aware datetimes
venv/lib/python3.14/site-packages/flask_oauthlib/provider/oauth2.py:864: TypeError
=============================== warnings summary ===============================
tests/test_admin.py::test_admin
tests/test_models.py::test_empty_redirect_uri_and_scope
tests/test_provider.py::test_oauthlib_monkeypatch
tests/test_provider.py::test_settings_index
    warnings.warn(
    return util.wrap_callable(lambda ctx: fn(), fn)  # type: ignore
    created = datetime.utcnow()
    return cls(int(id_s, 16), datetime.utcfromtimestamp(int(created_s, 16)))
    now = now or datetime.utcnow()
    _security.datetime_factory(),
    target.updated = datetime.utcnow()
tests/test_decorators.py::test_jwt_client
tests/test_decorators.py::test_jwt_client
tests/test_decorators.py::test_jwt_client
tests/test_decorators.py::test_jwt_client
tests/test_decorators.py::test_jwt_client
    now = datetime.utcnow()
tests/test_decorators.py::test_jwt_client
  /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/jwt/api_jwt.py:153: InsecureKeyLengthWarning: The HMAC key is 9 bytes long, which is below the minimum recommended length of 32 bytes for SHA256. See RFC 7518 Section 3.2
    return self._jws.encode(
tests/test_decorators.py::test_jwt_client
  /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/jwt/api_jwt.py:371: InsecureKeyLengthWarning: The HMAC key is 9 bytes long, which is below the minimum recommended length of 32 bytes for SHA256. See RFC 7518 Section 3.2
    decoded = self.decode_complete(
tests/test_models.py::test_empty_redirect_uri_and_scope
  /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/tests/test_models.py:34: SAWarning: Object of type <Client> not in session, add operation along 'User.oauth2clients' will not proceed
    with db.session.begin_nested():
tests/test_models.py::test_token_scopes
  /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/tests/conftest.py:271: SAWarning: Object of type <Client> not in session, add operation along 'User.oauth2clients' will not proceed (This warning originated from the Session 'autoflush' process, which was invoked automatically in response to a user-initiated operation. Consider using ``no_autoflush`` context manager if this warning happened while initializing objects.)
    app.test_user = lambda: db.session.get(User, test_user_id)
tests/test_models.py::test_token_scopes
  /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/tests/test_models.py:80: SAWarning: Object of type <Token> not in session, add operation along 'User.oauth2tokens' will not proceed
    with db.session.begin_nested():
    warnings.warn(
tests/test_provider.py::test_refresh_flow
tests/test_provider.py::test_implicit_flow
tests/test_provider.py::test_client_flow
tests/test_provider.py::test_info_not_accessible_in_production
tests/test_provider.py::test_expired_refresh_flow
tests/test_provider.py::test_not_allowed_public_refresh_flow
tests/test_provider.py::test_password_grant_type
tests/test_provider.py::test_email_scope
    expires = datetime.utcnow() + timedelta(seconds=int(expires_in))
tests/test_provider.py::test_auth_flow_denied
    log.warn(
tests/test_settings.py::test_authorized_app_revocation
  /home/runner/work/test-zip-extract-repository/test-zip-extract-repository/workdir/tests/invenio-oauth2server/original/.venv/lib/python3.14/site-packages/flask_security/datastore.py:219: SAWarning: Object of type <Client> not in session, add operation along 'User.oauth2clients' will not proceed (This warning originated from the Session 'autoflush' process, which was invoked automatically in response to a user-initiated operation. Consider using ``no_autoflush`` context manager if this warning happened while initializing objects.)
    rv = self.user_model.query.filter(query).first()
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.14.2-final-0 ________________
Name                                                                      Stmts   Miss  Cover   Missing
invenio_oauth2server/__init__.py                                              5      0   100%
invenio_oauth2server/admin.py                                                23      0   100%
invenio_oauth2server/alembic/4e57407b8e4a_add_on_delete_cascade.py           25     18    28%   22-73, 83-121
invenio_oauth2server/alembic/12a88921ada2_create_oauth2server_tables.py      19     10    47%   25-82, 93-101
invenio_oauth2server/alembic/aa546f2a8d2f_create_oauth2server_branch.py       8      2    75%   21, 26
invenio_oauth2server/cli.py                                                  56      6    89%   39, 81, 93-97
invenio_oauth2server/config.py                                               22      0   100%
invenio_oauth2server/decorators.py                                           33      0   100%
invenio_oauth2server/errors.py                                               38      2    95%   41, 59
invenio_oauth2server/ext.py                                                 132     10    92%   48-50, 106-107, 192, 194, 233, 236, 343-345
invenio_oauth2server/forms.py                                                58      1    98%   51
invenio_oauth2server/models.py                                              170      5    97%   75, 80, 206-208
invenio_oauth2server/provider.py                                             58      4    93%   60, 123, 153-155
invenio_oauth2server/proxies.py                                               4      0   100%
invenio_oauth2server/scopes.py                                                4      0   100%
invenio_oauth2server/theme/semantic/form_styling.py                          20     14    30%   19, 23-40, 45
invenio_oauth2server/utils.py                                                30      1    97%   68
invenio_oauth2server/validators.py                                           26      0   100%
invenio_oauth2server/views/__init__.py                                        3      0   100%
invenio_oauth2server/views/server.py                                         69     12    83%   46-53, 71, 97, 137-146, 153-157
invenio_oauth2server/views/settings.py                                      117      6    95%   42, 70, 203, 233, 268-269
TOTAL                                                                       920     91    90%
=========================== short test summary info ============================
FAILED tests/test_provider.py::test_refresh_flow - TypeError: can't compare offset-naive and offset-aware datetimes
FAILED tests/test_provider.py::test_implicit_flow - TypeError: can't compare offset-naive and offset-aware datetimes
FAILED tests/test_provider.py::test_client_flow - TypeError: can't compare offset-naive and offset-aware datetimes
FAILED tests/test_provider.py::test_info_not_accessible_in_production - assert 500 == 404
 +  where 500 = <WrapperTestResponse streamed [500 INTERNAL SERVER ERROR]>.status_code
FAILED tests/test_provider.py::test_expired_refresh_flow - TypeError: can't compare offset-naive and offset-aware datetimes
FAILED tests/test_provider.py::test_not_allowed_public_refresh_flow - TypeError: can't compare offset-naive and offset-aware datetimes
============ 6 failed, 54 passed, 1 skipped, 465 warnings in 21.28s ============
 Container docker_services_cli-postgresql-1  Stopping
 Container docker_services_cli-postgresql-1  Stopped
 Container docker_services_cli-postgresql-1  Removing
 Container docker_services_cli-postgresql-1  Removed
 Network docker_services_cli_default  Removing
 Network docker_services_cli_default  Removed
